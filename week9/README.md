

## homework
    a.总结几种 socket 粘包的解包方式: fix length/delimiter based/length field based frame decoder。尝试举例其应用
    b.实现一个从 socket connection 中解码出 goim 协议的解码器。
## 粘包定义

## 产生原因

## 解决方法

就像上面说的，UDP 之所以不会产生粘包和半包问题，主要是因为消息有边界，因此，我们也可以采取类似的思路。
### 改成短连接

将 TCP 连接改成短连接，一个请求一个短连接。这样的话，建立连接到释放连接之间的消息即为传输的信息，消息也就产生了边界。

这样的方法就是十分简单，不需要在我们的应用中做过多修改。但缺点也就很明显了，效率低下，TCP 连接和断开都会涉及三次握手以及四次握手，每个消息都会涉及这些过程，十分浪费性能。

因此，并不推介这种方式。
### 封装成帧

封装成帧(Framing)，也就是原本发送消息的单位是缓冲大小，现在换成了帧，这样我们就可以自定义边界了。一般有4种方式：
### 固定长度

这种方式下，消息边界也就是固定长度即可。

优点就是实现很简单，缺点就是空间有极大的浪费，如果传递的消息中大部分都比较短，这样就会有很多空间是浪费的。

因此，这种方式一般也是不推介的。
### 分隔符

这种方式下，消息边界也就是分隔符本身。

优点是空间不再浪费，实现也比较简单。缺点是当内容本身出现分割符时需要转义，所以无论是发送还是接受，都需要进行整个内容的扫描。

因此，这种方式效率也不是很高，但可以尝试使用。
### 专门的 length 字段

这种方式，就有点类似 Http 请求中的 Content-Length，有一个专门的字段存储消息的长度。作为服务端，接受消息时，先解析固定长度的字段（length字段）获取消息总长度，然后读取后续内容。

优点是精确定位用户数据，内容也不用转义。缺点是长度理论上有限制，需要提前限制可能的最大长度从而定义长度占用字节数。

因此，十分推介用这种方式。
### 其他方式

其他方式就各不相同了，比如 JSON 可以看成是使用{}是否成对。这些优缺点就需要大家在各自的场景中进行衡量了。


## Netty 中的实现

## Reference
[Netty-粘包和半包](https://zhuanlan.zhihu.com/p/88112396)
